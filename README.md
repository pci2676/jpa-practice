# JPA 소개

## JPA를 써야하는 이유

반복적인 CRUD 쿼리를 작성하지 않아도 된다. (Entity 필드 추가에 대해 유연한 대처가 가능하다)

객체와 관계형 데이터 베이스간의 **패러다임의 불일치를 해소**할 수 있다.  
상속, 연관 관계, 데이터 타입, 데이터 식별 방법 등...

데이터베이스 방언에 종속되어 있지 않다.

## 영속성 컨텍스트

### 엔티티 매니저 팩토리와 엔티티 매니저

요청마다 팩토리에서 엔티티 매니저를 하나 생성하고 엔티티 매니저는 커넥션풀에서 커넥션을 하나씩 가져가서 사용한다.

### 영속성 컨텍스트

엔티티를 영구 저장하는 환경이라는 뜻

persists는 디비에 저장하는 것을 의미하는게 아니라 영속성 컨텍스트에 저장한다는 것이다.

영속성 컨텍스트는 논리적인 개념이라 눈에 보이지 않는다. 매니저를 통해 컨텍스트에 접근한다.

엔티티 매니저를 생성하면 1:1로 영속성 컨텍스트가 생성된다.

### 엔티티의 생명주기

비영속 : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태

영속 : 영속성 컨텍스트에서 관되는 상태 persist를 하면 이 상태로 온다.

준영속 : 영속성 컨텍스트에서 저장되었다가 분리된 상태

삭제 : 삭제

#### 비영속

객체를 생성한 상태이다. 즉, 영속성 컨텍스트와 관련이 없다.

#### 영속

비영속 상태의 객체를  persist를 하는 순간 영속 상태가 된 것이다.

아직 디비에 저장된 상태는 아니다.  
저장이 되려면 트랜잭션이 커밋이 되어야 한다.

#### 준영속, 삭제

엔티티를 영속성 컨텍스트에서 분리한다.

엔티티를 삭제한다.

### 영속성 컨텍스트의 이점

- 1차캐시
- 동일성 보장 (==)
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연 로딩

#### 엔티티 조회, 1차캐시

persist하는 순간 1차캐시에 저장이된다.

그 다음 조회한다면 1차캐시에서 우선적으로 찾아서 결과를 가져온다.

1차 캐시에서 없는 엔티티를 조회하려 한다면 데이터 베이스에서 조회를 해서 결과를 1차캐시에 넣고 결과를 준다.

애플리케이션에서 전체가 공유하는 캐시가 아니라 엔티티 매니저 하나가 사용하고 삭제하는 캐시이다.

#### 영속 엔티티의 동일성 보장

1차 캐시로 반복 가능한 읽기 등급의 트랜잭션 격리수준(REPEATABLE READ)을 데이터베이스가 아닌 애플리케이션 차원에서 제공한다.

#### 엔티티를 등록할때 트랜잭션을 지원하는 쓰기 지연

트랜잭션 내에서 발생하는 INSERT 쿼리를 다 쌓아두고 commit 할때 한꺼번에 데이터베이스에 전송한다.

SQ을 저장하는 곳은 쓰기지연 SQL 저장소이다.

이때 flush를 실행하면서 SQL을 전송한다.

> 엔티티는 상속을 이용해서 생성하기 때문에 protect 이상의 기본생성자가 필요하다.

SQL을 모을수 있는 양은 batch.size를 조절해서 설정할 수 있다.

#### 엔티티 수정, 변경감지 Dirty Checking

commit을 하기 직전에 flush가 실행되고 엔티티와 스냅샷(1차캐시에 저장되어 있는)을 비교한다.

변경된 부분에 대한 UPDATE 쿼리를 작성해서 쓰기 지연 저장소에 저장하고 flush를 하여 데이터 베이스에 반영한다.

#### 플러시

영속성 컨텍스트의 변경내용을 데이터 베이스에 반영하는 작업을 의미한다.

##### 플러시 발생

변경 감지 실행

수정된 엔티티 쓰기 지연 SQL 저장소에 등록

쓰기지연 SQL 저장소의 쿼리를 데이터베이스에 전송

#### 영속성 컨텍스트를 플러시하는 방법

- em.flush() - 직접 호출

- 트랜잭션 커밋 - 플러시 자동 호출

- JPQL 쿼리 실행 - 플러시 자동 호출 - 1차캐시를 사용하지 않기 때문일 것 같다.

플러시를 한다해서 1차 캐시를 지우는 것이 아니다.

플러시 모드는 AUTO(커밋이나 실행할때 플러시 기본값), COMMIT(커밋을 할때만 플러시)

#### 플러시는!

영속석 컨텍스트를 비우지 않음

영속성 컨텍스트의 변경내용을 데이터 베이스와 동기화하는 작업이다

트랜잭션이라는 작업단위가 중요하다 커밋 직전에만 동기화하면 됨

### 준영속 상태

영속 -> 준영속

영속 ㅅ강태의 엔티티가 영속성 컨텍스트에서 분리

영속성 컨텍스트가 제공하는 기능을 사용하지 못한다.

#### 만드는 법

- em.detach(E e); - 하나 초기화

- em.clear() - 통째로 초기화
- em.close() - 영속성 컨텍스트를 종료해버린다.

## 엔티티 맵핑

JPA의 내부 매커니즘과 설계적인 측면이 가장 중요한 두 요소이다.

유니크 키 제약조건 생성방법

```
@Table(
        uniqueConstraints = @UniqueConstraint(
                name = "UK_MEMBER_NAME", columnNames = "NAME")
)
```

권장하는 식별자 전략은

Long 형 + 대체키 + 키 생성전략 사용 

IDENTITY 전략은 쓰기지연을 할 수 없다.

## 연관관계 맵핑

객체와 테이블의 연관관계의 차이점은 연관관계를 1개를 맺느냐(데이터베이스) 2개를 맺느냐(객체)의 차이가 있다.

사실상 객체의 양방향 관계는 서로 다른 단방향 2개를 연결한 것이다.

문제는 **외래키를 누가 업데이트 할것인가?**

연관관계의 주인만이 외래키를 관리(=변경) 할 수 있다.

주인이 아닌 쪽은 읽기만 가능하다.

`mappedBy` : 연관관계의 주인이 아니라는 마크를 해준다. 연결된 객체에서 사용되는 변수의 이름을 사용한다.

외래키가 있는 곳을 주인으로 정해라. 일반적으로 그냥 N쪽이 연관관계의 주인이 된다고 보면된다.

### 양방향 연관관계 맵핑시 주의점

연관관계의 주인에게 값을 입력해야지 (주인이 들고있는 연관객체에) 업데이트 쿼리가 발생한다.  
연관관계의 주인이 아닌 객체에게 값을 주입하는 경우 업데이트 쿼리는 발생하지 않는다.

순수객체라고 생각하고 양쪽에 값을 주입해 주어야한다.

그냥 단방향으로 다 바르고 시작하고 되도록 양방향은 하지마라

## 다대일

 



## 일대다

`@JoinColumn`을 사용하지 않으면 중간에 조인 테이블이 생성되어 버린다.

관리해야하는 외래키가 다른 테이블에 위치한다는 것이 큰 단점으로 작용한다.

양방향으로 적용할때는 `Many`쪽에서 insertable, updatable을 false로 사용하여 읽기전용으로 사용하라.

일대다 양방향을 쓰지말고 다대일 양방향으로 사용하자.

## 일대일

외래키에 유니크 제약조건을 추가해주고 사용해야한다. 

대상 테이블에 지연로딩으로 설정을해도 프록시 기능의 한계 때문에 강제로 즉시 로딩된다.

## 다대다

